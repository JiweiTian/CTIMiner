'''
Created on Aug 20, 2016

This script defines classes for extracting IoCs in malware analysis results from malware repositories.
By calling getMalwareInfo function from outside of this script, one could extract IoCs or add them in MISP system.
Currently, the malware analysis results are extracted using malwares.com API of Saint Security inc.
Our system has tested under the API version 2.0.14.
If one has other API license of malware repositories such as Virustotal, 
one could use it by implementing additional class including getMalwareInfo function.

@author: Andrew D. Kim (aka Daegeon Kim)
'''
from abc import ABCMeta, abstractmethod
import requests, zipfile, time
import LibIoC_DK, main
from pip._vendor.pkg_resources import null_ns_handler
from datetime import datetime
from _ctypes_test import func

'''
The Abstract class of MalwareRepositoryConnector.                         
Any malware repository could be used by implementing this abstract class. 
'''
class MalwareRepositoryConnector:
    __metaclass__ = ABCMeta
    
    ################################################################################################
    # Return true if the target file(or full file path) is belong to the file of interest defined by 'foi' variable
    # @ inputs
    #    target: the filename or full path including file extension.
    # @ outputs:
    #    Return True if the filename or full path is the file of interest by 'foi' variable.
    #    Otherwise, return False.
    ################################################################################################
    def isFileofInterest(self, target):
        return LibIoC_DK.isFileofInterest(target)

    @abstractmethod
    ################################################################################################
    # Get the information of the malware  by checking in the malware repository using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of malware info or True if the information is downloaded from the malware repository, otherwise return False
    #     The format of an element in the list should be ('source', 'type/comment', 'attribute').
    #     i.g. ('behavior', 'src_ip/C2 server', '1.1.1.1')
    # @ USAGE
    #    To get malware info as the result of this function, the second and the third parameter is not required.
    #    To add malware info into MISP system, the second and the third parameter is required.
    def getMalwareInfo(self, _hash, misp_event, misp): pass


'''
Implementation of MalwareRepositoryConnector using malware.com 
'''
class MalwaresDotCom(MalwareRepositoryConnector):
    # this is defined by referring the patterns of ioc_parser
    key = ''
    
    
    def __init__(self, api_key):
        self.key = api_key
    
    ################################################################################################
    # Download a malware from malwares.com site using the hash value
    # @ inputs
    #     _hash: the malware hash value to be downloaded
    #     save: the file save option. If true save the downloaded file.
    # @ outputs
    #     Return the downloaded file if save option is False, otherwise return True and save the file.
    ################################################################################################
    def downloadMalware(self, _hash, save=False):
        
        _params = {
        'api_key': self.key,
        'hash': _hash,
        }
        
        try:
            response = requests.get('https://www.malwares.com/api/v2/file/download', params=_params)
        except:
            return False
        
        if response == None or response == '':
            return False
                 
        if response.status_code < 0:
            return False
        
        downloaded_file = response.content
    
        # Save Malware File
        if save:
            f = open(_hash, 'w')
            f.write(downloaded_file)
            f.close()
            self.unzipMalware(_hash)
            return True
        
        return downloaded_file
    
        
    def unzipMalware (self, _hash) :
        fzip = zipfile.ZipFile(_hash, 'r')
        fzip.extractall()
        fzip.close()
        
        
    ################################################################################################
    # Get the static and the behavior information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of malware info or True if the information is downloaded from malwares.com site, otherwise return False
    #     The format of an element in the list should be ('source', 'type/comment', 'attribute').
    #     i.g. ('behavior', 'src_ip/C2 server', '1.1.1.1')
    # @ USAGE
    #    To get the malware info as the result of this function, the second and the third parameter is not required.
    #    To add the malware info into MISP system, the second and the third parameter is required.
    def getMalwareInfo(self, _hash, misp_event=False, misp=False):
        result1 = self.getMalwareStaticInfo(_hash, misp_event, ) 
        if result1:
            result2 = self.getMalwareBehaviorInfo(_hash, misp_event, misp)
            if misp_event and misp:
                return result1 or result2
            else:
                if result2:
                    return result1 + result2
                else:
                    return result1
        else:
            return False
        
            
    ################################################################################################
    # Get static information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of static info or True if the static information is downloaded from malwares.com site, otherwise return False
    # @ USAGE
    #    To get malware static info as the result of this function, the second and the third parameter is not required.
    #    To add malware static info into MISP system, the second and the third parameter is required.
    def getMalwareStaticInfo(self, _hash, misp_event=False, misp=False):
        add_result_to_system = False
        if misp_event and misp:
            add_result_to_system = True
        retval = []
        
        _params = {
        'api_key': self.key,
        'hash': _hash
        }

        response = None
        static = None
        counter = 0
        while True:
            try:
                response = requests.get('https://www.malwares.com/api/v2/file/staticinfo', params=_params)
            except:
                return False
            
            if response == None or response == '':
                return False
             
            static = response.json()
            
            if counter >= main._COUNTER_LIMIT_:
                return False
            elif static['result_code'] == 1: # Data exists
                break
            elif static['result_code'] == 2: # Analyzing
                print "[Static Info] Analyzing ("+_hash+")"
                counter += 1
                if main._COUNTER_LIMIT_ > 1:
                    time.sleep(300)
            elif static['result_code'] == -14:  # Over the daily request limit
                print "[Static Info] Over the daily request limit"
                counter += 1
                if main._COUNTER_LIMIT_ > 1:
                    time.sleep(600)
            elif static['result_code'] <= 0:
                return False
                
        # add all different hash representations of the malware 
        if 'md5' in static:
            static_input = ('static','md5',static['md5'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
        if 'sha1' in static:
            static_input = ('static','sha1',static['sha1'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
        if 'sha256' in static:
            static_input = ('static','sha256',static['sha256'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
            
        # add string information in the malware
        if 'strings_result' in static and static['strings_result'] is not None:
            for _str in static['strings_result']['strings']:

                if _str['pattern'] == 'url':
                    # since the returned string results does not always contain clear ioc, filter the outputs.
                    ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
                    if ioc is not None:
                        for _ioc in ioc:
                            static_input = ('static','url',_ioc)
                            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                    
                elif _str['pattern'] == 'ip':                    
                    # since the returned string results does not always contain clear ioc, filter the outputs.
                    ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
                    if ioc is not None:
                        for _ioc in ioc:
                            static_input = ('static','ip',_ioc)
                            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                
                elif _str['pattern'] == 'path':
#                    if _str['strings'].endswith('.pdb'):
#                        retval.append(('filepath',_str['strings']))
                    if LibIoC_DK.isFileofInterest(_str['strings']):
                        static_input = ('static','filepath',_str['strings'])
                        retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                            
                elif _str['pattern'] == 'hash':

                    # since the returned string results does not always contain clear ioc, filter the outputs.
                    ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
                    if ioc is not None:
                        # this condition filters irrelevant strings look like hash values
                        if len(ioc) > 1:
                            remove_val = []
                            for i in range(len(ioc)-1):
                                if remove_val.count(ioc[i]) != 0:
                                    continue
                                for j in range(i+1,len(ioc)):
                                    tmp1 = ioc[i].encode('utf-8')
                                    tmp2 = ioc[j].encode('utf-8')
                                    if tmp1 in tmp2:
                                        if remove_val.count(ioc[i]) == 0:
                                            remove_val.append(ioc[i])
                                        if remove_val.count(ioc[j]) == 0:
                                            remove_val.append(ioc[j])
                            for r in range(len(remove_val)):
                                while ioc.count(remove_val[r]) != 0:
                                    ioc.remove(remove_val[r])
                        
                        for _ioc in ioc:
                            _ioc = _ioc.encode('utf-8')
                            tmp_size = len(retval)
                            if len(_ioc) == 32:
                                static_input = ('static','md5',_ioc)
                                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                            elif len(_ioc) == 40:
                                static_input = ('static','sha1',_ioc)
                                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                            elif len(_ioc) == 64:
                                static_input = ('static','sha256',_ioc)
                                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                            
                            if (add_result_to_system and retval) or (not add_result_to_system and len(retval)>tmp_size):
                                self.getMalwareStaticInfo(_ioc)
                                self.getMalwareBehaviorInfo(_ioc)
                            
                else:
                    if _str['strings']:
                        if LibIoC_DK.checkIoCType(_str['strings']) == 'email':
                            static_input = ('static','email',_str['strings'])
                        else:
                            static_input = ('static','string',_str['strings'])
                            
                        retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
            
        # store digital signature information of the malware if available
        if 'peinfo' in static:
#            if 'internal_name' in static['peinfo']['file_info']:
#                static_input = ('static','filename/internal_name',static['peinfo']['file_info']['internal_name'])
#                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                      
            if 'original_filename' in static['peinfo']['file_info'] and static['peinfo']['file_info']['original_filename']:
                static_input = ('static','filename/original_filename',static['peinfo']['file_info']['original_filename'])
                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                      
            if static['peinfo']['signcheck']['verified'] != 'Unsigned':
                for s in static['peinfo']['signcheck']['signers_details']:
                    static_input = ('static','signcheck/digital sign serial number',s['serial_number'])
                    retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                      
        if type(retval) and len(retval) > 0:  
            return retval
        else:
            False
            
          
    ################################################################################################
    # Get behavior information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the behavior information
    #     misp_event: the created MISP event handle to store the behavior information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of behavior info or True if the static information is downloaded from malwares.com site, otherwise return False
    # @ USAGE
    #    To get malware behavior info as the result of this function, the second and the third parameter is not required.
    #    To add malware behavior info into MISP system, the second and the third parameter is required.
    def getMalwareBehaviorInfo(self, _hash, misp_event=False, misp=False):
        add_result_to_system = False
        if misp_event and misp:
            add_result_to_system = True
            
        retval = []
        
        _params = {
        'api_key': self.key,
        'hash': _hash,
        'env_type': 2
        }
        
        response = None
        behavior = None
        counter = 0
        while True:
            try:
                response = requests.get('https://www.malwares.com/api/v2/file/behaviorinfo', params=_params)
            except:
                return False
            
            behavior = response.json()
            
            if counter >= 1:
                return False
            elif behavior['result_code'] == 1: # Data exists
                break
            elif behavior['result_code'] == 2:  # Analyzing
                print "[Behavior Info] Analyzing ("+_hash+")"
                counter += 1
                if main._COUNTER_LIMIT_ > 1:
                    time.sleep(300) # try again after 5 minutes
            elif behavior['result_code'] == -14:  # Over the daily request limit
                print "[Behavior Info] Over the daily request limit"
                counter += 1
                if main._COUNTER_LIMIT_ > 1:
                    time.sleep(600)
            elif behavior['result_code'] <= 0:
                return False
            
        # add all different malware hash representations 
        if 'md5' in behavior:
            behavior_input = ('behavior','md5',behavior['md5'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
        if 'sha1' in behavior:
            behavior_input = ('behavior','sha1',behavior['sha1'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
        if 'sha256' in behavior:
            behavior_input = ('behavior','sha256',behavior['sha256'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
            
        # add behavior analysis results
        if 'behavior' in behavior:
            for bb in behavior['behavior']:
                if 'file_write_event' in bb and bb['file_write_event'] is not None:
                    for _filename in bb['file_write_event']:
                        if LibIoC_DK.isFileofInterest(_filename['filename']):
                            behavior_input = ('behavior','filename/file_write_event',_filename['filename'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                            
                if 'service_create_event' in bb and bb['service_create_event'] is not None:
                    for service in bb['service_create_event']:
                        if service['displayname']:
                            behavior_input = ('behavior','string/service display name',service['displayname'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                    
        # add network analysis results
        if 'network' in behavior and behavior['network'] is not None:
            for flow in behavior['network']['flow']:
                flow_type = flow['protocol']
                if flow['application']:
                    flow_type += '_'+flow['application']
                
                if flow['application'] == 'DNS':
                    for detail in flow['detail_info']:
                        if detail['dns_msg_type'] == 'QUERY':
                            behavior_input = ('behavior','host/'+flow_type,detail['query_name'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                        elif detail['dns_msg_type'] == 'ANSWER_IPV4':
                            behavior_input = ('behavior','dest_ip/'+flow_type,detail['ipv4_address'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                elif flow['protocol'] == 'TCP' or flow['protocol']=='UDP' or flow['protocol']=='IGMP' or flow['protocol']=='IGMP':
                    if flow['dest_ip'] != '<MWS_GUEST_IP>':   # malwares.com virtual machine IP
                        behavior_input = ('behavior','dest_ip/'+flow_type,flow['dest_ip'])
                        retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                    elif flow['src_ip'] != '<MWS_GUEST_IP>':   # malwares.com virtual machine IP
                        behavior_input = ('behavior','src_ip/'+flow_type,flow['src_ip'])
                        retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                    
        if type(retval)==list and len(retval) > 0:  
            return retval
        else:
            False
           
           
    ################################################################################################
    # Add extracted info from the repository into MISP system or into extracted info list.
    # The duplication of info in MISP is checked when it is added into the system or appended into the info list.
    # @ input
    #    info : the extracted information from the repository
    #    add_to_system : the indicator whether the info is added into MISP or appended into the info_list
    #    info_list : the information list extracted from the repository. If add_to_system is False, list type of parameter should be passed.
    #    misp : the MISP instance. This should not be False if add_to_system is True.
    #    misp_event : the MISP event this info is added. This should not be False if add_to_system is True.
    # @ output
    #    True or the info list is returned if the info is added into MISP or info_list.
    #    Otherwise, False is returned.
    def addExtractedInfo(self, info, add_to_system=False, info_list=None, misp=False, misp_event=False):
        if add_to_system and misp and misp_event:
            if misp and misp_event:
                return misp.addAttribute(misp_event, info)
        elif type(info_list) == list:
            if info_list.count(info) == 0:
                info_list.append(info)
            return info_list
            
    
    def getMalwareCollectedDate(self, _hash):
           
        _params = {
        'api_key': self.key,
        'hash': _hash,
        'env_type': 2
        }
        
        response = None
        try:
            response = requests.get('https://www.malwares.com/api/v2/file/mwsinfo', params=_params)
        except:
            return False
        
        summary = response.json()
        
        if summary['result_code'] <= 0 and summary['result_code'] != 2:
            return False
         
        return summary['first_seen'].encode('utf-8')[0:10]
    

class Virustotal(MalwareRepositoryConnector):
    
    #############################
    # variables related to API key's property
    property={}
    property['request_rate'] = 4    # per minute
    property['daily_quota'] = 5760  # per day
    
    API_used_counter = {}
    API_used_counter['request_rate'] = 0    # per minute
    API_used_counter['daily_quota'] = 0  # per day
    
    minute_timer = None
    daily_timer = None
    
     
    def checkMinuteTimerLimit(self):
        return ((self.minute_timer-datetime.now()).total_seconds()) > 60
                   
    def checkRequestRate(self):
        return self.API_used['request_rate'] < self.property['request_rate']
    
    def checkDailyQuota(self):
        return self.API_used['daily_quota'] < self.property['daily_quota']