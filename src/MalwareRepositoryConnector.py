'''
Created on Aug 20, 2016

This script defines classes for extracting IoCs in malware analysis results from malware repositories.
By calling getMalwareInfo function from outside of this script, one could extract IoCs or add them in MISP system.
Currently, the malware analysis results are extracted using malwares.com API of Saint Security inc.
Our system has tested under the API version 2.0.14.
If one has other API license of malware repositories such as Virustotal, 
one could use it by implementing additional class including getMalwareInfo function.

@author: Andrew D. Kim (aka Daegeon Kim)
'''
from abc import ABCMeta, abstractmethod
import requests, zipfile, time, io
import LibIoC_DK, main
from pip._vendor.pkg_resources import null_ns_handler
from datetime import datetime
from _ctypes_test import func

'''
The Abstract class of MalwareRepositoryConnector.                         
Any malware repository could be used by implementing this abstract class. 
'''
class MalwareRepositoryConnector:
    __metaclass__ = ABCMeta
    
    ################################################################################################
    # Return true if the target file(or full file path) is belong to the file of interest defined by 'foi' variable
    # @ inputs
    #    target: the filename or full path including file extension.
    # @ outputs:
    #    Return True if the filename or full path is the file of interest by 'foi' variable.
    #    Otherwise, return False.
    ################################################################################################
    def isFileofInterest(self, target):
        return LibIoC_DK.isFileofInterest(target)

    @abstractmethod
    ################################################################################################
    # Get the information of the malware  by checking in the malware repository using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of malware info or True if the information is downloaded from the malware repository, otherwise return False
    #     The format of an element in the list should be ('source', 'type/comment', 'attribute').
    #     i.g. ('behavior', 'src_ip/C2 server', '1.1.1.1')
    # @ USAGE
    #    To get malware info as the result of this function, the second and the third parameter is not required.
    #    To add malware info into MISP system, the second and the third parameter is required.
    def getMalwareInfo(self, _hash, misp_event, misp): pass


'''
Implementation of MalwareRepositoryConnector using malware.com 
'''
class MalwaresDotCom(MalwareRepositoryConnector):
    # this is defined by referring the patterns of ioc_parser
    key = ''
    query_counter = 0
    normal_process_list = 'normalProcessList.xml'
    normal_process_list_root = None
    
    
    def __init__(self, api_key):
        self.key = api_key
        self.normal_process_list_root = self.openNormalProcessList()
    
    ################################################################################################
    # Download a malware from malwares.com site using the hash value
    # @ inputs
    #     _hash: the malware hash value to be downloaded
    #     save: the file save option. If true save the downloaded file.
    # @ outputs
    #     Return the downloaded file if save option is False, otherwise return True and save the file.
    ################################################################################################
    def downloadMalware(self, _hash, save=False):
        
        _params = {
        'api_key': self.key,
        'hash': _hash,
        }
        
        try:
            LibIoC_DK.debugging("Downloading the malware: %s"%(_hash), main._DEBUG_, main._LOGGING_, main.hFile)
            response = requests.get('https://public.api.malwares.com/v3/file/download', params=_params)
            self.query_counter = self.query_counter + 1
        except:
            print('downloadMalware exception!')
            return False
        
        if response == None or response == '':
            LibIoC_DK.debugging("NO response returned while downloading the malware", main._DEBUG_, main._LOGGING_, main.hFile)
            return False
                 
        if response.status_code < 0 or 'Invalid type of hash' in response.content:
            LibIoC_DK.debugging("Error returned while downloading the malware", main._DEBUG_, main._LOGGING_, main.hFile)
            return False
        
        downloaded_file = response.content
    
        # Save Malware File
        if save:
            f = open(_hash, 'w')
            f.write(downloaded_file)
            f.close()
            self.unzipMalware(_hash)
            return True
        
        return downloaded_file
    
        
    def unzipMalware (self, _hash, save_dir=None) :
        f = open(_hash, 'rb')
        fzip = zipfile.ZipFile(io.BytesIO(f.read()))
        fzip.extractall(save_dir)
        extracted = fzip.namelist()
        fzip.close()
        f.close()
        
        return extracted[0]
        
             
    ################################################################################################
    # Get the static and the behavior information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of malware info or True if the information is downloaded from malwares.com site, otherwise return False
    #     The format of an element in the list should be ('source', 'type/comment', 'attribute').
    #     i.g. ('behavior', 'src_ip/C2 server', '1.1.1.1')
    # @ USAGE
    #    To get the malware info as the result of this function, the second and the third parameter is not required.
    #    To add the malware info into MISP system, the second and the third parameter is required.
    def getMalwareInfo(self, _hash, misp_event=False, misp=False):
        
        LibIoC_DK.debugging("Getting the malware info: %s" %(_hash) , main._DEBUG_, main._LOGGING_, main.hFile)
        result1 = self.getMalwareStaticInfo(_hash, misp_event, ) 
        if result1:
            result2 = self.getMalwareBehaviorInfo(_hash, misp_event, misp)
            if misp_event and misp:
                return result1 or result2
            else:
                if result2:
                    return result1 + result2
                else:
                    return result1
        else:
            LibIoC_DK.debugging("NO the malware info found: %s" %(_hash), main._DEBUG_, main._LOGGING_, main.hFile)
            return False
        
            
    ################################################################################################
    # Get static information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the static information
    #     misp_event: the created MISP event handle to store the static information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of static info or True if the static information is downloaded from malwares.com site, otherwise return False
    # @ USAGE
    #    To get malware static info as the result of this function, the second and the third parameter is not required.
    #    To add malware static info into MISP system, the second and the third parameter is required.
    def getMalwareStaticInfo(self, _hash, misp_event=False, misp=False):
        add_result_to_system = False
        if misp_event and misp:
            add_result_to_system = True
        retval = []
        
        _params = {
        'api_key': self.key,
        'hash': _hash
        }

        response = None
        static = None
        
        if self.getAIScore(_hash) < 60:
            return False
        
        while True:
            try:
                LibIoC_DK.debugging("Getting the malware static info", main._DEBUG_, main._LOGGING_, main.hFile)
                response = requests.get('https://public.api.malwares.com/v3/file/staticinfo', params=_params)
                self.query_counter = self.query_counter + 1
            except:
                LibIoC_DK.debugging("Exception occurred during the malware static info request", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
            if response == None or response == '':
                LibIoC_DK.debugging("NO response returned as the malware static info", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
            try:
                static = response.json()
            except:
                LibIoC_DK.debugging("Exception occurred during decoding response", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
            if static['result_code'] == 1: # Data exists
                break
            elif static['result_code'] == 2: # Analyzing
                print("[Static Info] Analyzing ("+_hash+")")
                return False
            elif static['result_code'] == -14:  # Over the daily request limit
                LibIoC_DK.debugging("Over the daily request limit", main._DEBUG_, main._LOGGING_, main.hFile)
                LibIoC_DK.debugging("Accumulated the number of query: %d" %(self.query_counter), main._DEBUG_, main._LOGGING_, main.hFile)
                self.waitToNextMidnight_UTC()
                self.query_counter = 0
            elif static['result_code'] <= 0:
                LibIoC_DK.debugging("Error returned while getting the malware static info", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
                
        # add all different hash representations of the malware 
        if 'md5' in static:
            static_input = ('static','md5',static['md5'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
        if 'sha1' in static:
            static_input = ('static','sha1',static['sha1'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
        if 'sha256' in static:
            static_input = ('static','sha256',static['sha256'])
            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
            
        # add string information in the malware
        if 'strings_result' in static and static['strings_result'] is not None:
            prev_offset = 0
            for _str in static['strings_result']['strings']:
                # The concatenated attribute the right after previous one without null string, we ignore it. 
                offset_distance = int(_str['offset'],16) - prev_offset
                prev_offset = int(_str['offset'],16)
                charset = _str['charset']
                if charset == 'ascii':
                    charset_len = 1
                elif charset == 'unicode':
                    charset_len = 2
                    
                if offset_distance <= len(_str['strings'])*charset_len:
                    continue
                
                if _str['pattern'] == 'url':
                    # since the returned string results does not always contain clear ioc, filter the outputs.
                    ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
                    if ioc is not None:
                        for _ioc in ioc:
                            static_input = ('static','url',_ioc)
                            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                    
                elif _str['pattern'] == 'ip':                    
                    # since the returned string results does not always contain clear ioc, filter the outputs.
                    ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
                    if ioc is not None:
                        for _ioc in ioc:
                            if _ioc.endswith('0.0'):
                                continue
                            static_input = ('static','ip',_ioc)
                            retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                
                elif _str['pattern'] == 'path':
                    if LibIoC_DK.isFileofInterest(_str['strings']):
                        static_input = ('static','filepath',_str['strings'])
                        retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
 
                # We found the almost the hash attribute returned as static analysis is errornous and meaningless,
                # since it is very unusual to insert hashes with in the malware code.
                elif _str['pattern'] == 'hash':
                    None
# 
#                     # since the returned string results does not always contain clear ioc, filter the outputs.
#                     ioc = LibIoC_DK.filterRegularIoC(_str['strings'], _str['pattern'])
#                     if ioc is not None:
#                         # this condition filters irrelevant strings look like hash values
#                         if len(ioc) > 1:
#                             remove_val = []
#                             for i in range(len(ioc)-1):
#                                 if remove_val.count(ioc[i]) != 0:
#                                     continue
#                                 for j in range(i+1,len(ioc)):
#                                     tmp1 = ioc[i].encode('utf-8')
#                                     tmp2 = ioc[j].encode('utf-8')
#                                     if tmp1 in tmp2:
#                                         if remove_val.count(ioc[i]) == 0:
#                                             remove_val.append(ioc[i])
#                                         if remove_val.count(ioc[j]) == 0:
#                                             remove_val.append(ioc[j])
#                             for r in range(len(remove_val)):
#                                 while ioc.count(remove_val[r]) != 0:
#                                     ioc.remove(remove_val[r])
#                         
#                         for _ioc in ioc:
#                             _ioc = _ioc.encode('utf-8')
#                             if len(_ioc) == 32:
#                                 static_input = ('static','md5',_ioc)
#                                 retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
#                             elif len(_ioc) == 40:
#                                 static_input = ('static','sha1',_ioc)
#                                 retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
#                             elif len(_ioc) == 64:
#                                 static_input = ('static','sha256',_ioc)
#                                 retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                
                elif _str['pattern'] == 'email':        
                    static_input = ('static','email',_str['strings'])
                    retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                else:
                    if _str['strings']:
                        static_input = ('static','string',_str['strings'])
                        retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
            
        # store digital signature information of the malware if available
        if 'peinfo' in static:
#            if 'internal_name' in static['peinfo']['file_info']:
#                static_input = ('static','filename/internal_name',static['peinfo']['file_info']['internal_name'])
#                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                      
            if 'original_filename' in static['peinfo']['file_info'] and static['peinfo']['file_info']['original_filename']:
                static_input = ('static','filename/original_filename',static['peinfo']['file_info']['original_filename'])
                retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                                      
            if static['peinfo']['signcheck']['verified'] != 'Unsigned':
                for s in static['peinfo']['signcheck']['signers_details'] and '00:00:00:00:00' not in s['serial_number']:
                    static_input = ('static','signcheck/digital sign serial number',s['serial_number'])
                    retval = self.addExtractedInfo(static_input, add_result_to_system, retval, misp, misp_event)
                      
        if type(retval) and len(retval) > 0:  
            LibIoC_DK.debugging("The malware static info returned", main._DEBUG_, main._LOGGING_, main.hFile)
            return retval
        else:
            LibIoC_DK.debugging("The malware static info NOT returned", main._DEBUG_, main._LOGGING_, main.hFile)
            return False
            
          
    ################################################################################################
    # Get behavior information of the malware  by checking in the malwares.com site using the hash value
    # @ input
    #     _hash: the malware hash value to get the behavior information
    #     misp_event: the created MISP event handle to store the behavior information of the malware
    #     misp: the MISP handle connected to the server
    # @ output
    #     Return the list of behavior info or True if the static information is downloaded from malwares.com site, otherwise return False
    # @ USAGE
    #    To get malware behavior info as the result of this function, the second and the third parameter is not required.
    #    To add malware behavior info into MISP system, the second and the third parameter is required.
    def getMalwareBehaviorInfo(self, _hash, misp_event=False, misp=False):
        add_result_to_system = False
        if misp_event and misp:
            add_result_to_system = True
            
        retval = []
        
        _params = {
        'api_key': self.key,
        'hash': _hash,
        'env_type': 2
        }
        
        response = None
        behavior = None
        while True:
            try:
                LibIoC_DK.debugging("Getting the malware behavior info", main._DEBUG_, main._LOGGING_, main.hFile)
                response = requests.get('https://public.api.malwares.com/v3/file/behaviorinfo', params=_params)
                self.query_counter = self.query_counter + 1
            except:
                LibIoC_DK.debugging("Exception occurred during the malware behavior info request", main._DEBUG_, main._LOGGING_, main.hFile)
                return False

            try:
                behavior = response.json()
            except:
                LibIoC_DK.debugging("Exception occurred during decoding response", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
            if behavior['result_code'] == 1: # Data exists
                break
            elif behavior['result_code'] == 2:  # Analyzing
                LibIoC_DK.debugging("Analyzing the malware behavior info", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            elif behavior['result_code'] == -14:  # Over the daily request limit
                LibIoC_DK.debugging("Over the daily request limit", main._DEBUG_, main._LOGGING_, main.hFile)
                LibIoC_DK.debugging("Accumulated the number of query: %d" %(self.query_counter), main._DEBUG_, main._LOGGING_, main.hFile)
                self.waitToNextMidnight_UTC()
                self.query_counter = 0
            elif behavior['result_code'] <= 0:
                LibIoC_DK.debugging("Error returned while getting the malware behavior info", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
        # add all different malware hash representations 
        if 'md5' in behavior:
            behavior_input = ('behavior','md5',behavior['md5'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
        if 'sha1' in behavior:
            behavior_input = ('behavior','sha1',behavior['sha1'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
        if 'sha256' in behavior:
            behavior_input = ('behavior','sha256',behavior['sha256'])
            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
            
        # add behavior analysis results
        if 'behavior' in behavior:
            for bb in behavior['behavior']:
                if 'file_write_event' in bb and bb['file_write_event'] is not None:
                    for _filename in bb['file_write_event']:
                        if LibIoC_DK.isFileofInterest(_filename['filename']):
                            behavior_input = ('behavior','filename/file_write_event',_filename['filename'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                            
                if 'service_create_event' in bb and bb['service_create_event'] is not None:
                    for service in bb['service_create_event']:
                        if service['displayname']:
                            behavior_input = ('behavior','string/service display name',service['displayname'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                            
                if 'process_create_event' in  bb and bb['process_create_event'] is not None:
                    for process in bb['process_create_event']:
                        if 'sha256' in process and process['sha256'].lower() != behavior['sha256'].lower():
                            if self.isNormalProcess(self.normal_process_list_root, process['sha256'].lower()):
                                continue
                            ai_score = self.getAIScore(process['sha256'])
                            if ai_score >= 70:
                                behavior_input = ('behavior','sha256',process['sha256'])
                                retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                            else:
                                LibIoC_DK.debugging("Normal process", main._DEBUG_, main._LOGGING_, main.hFile)
                                self.addNormalProcessList(self.normal_process_list_root, process['newprocessname'], process['sha256'].lower(), str(ai_score))
                                self.saveNormalProcessList(self.normal_process_list_root)
                    
        # add network analysis results
        if 'network' in behavior and behavior['network'] is not None:
            for flow in behavior['network']['flow']:
                flow_type = flow['protocol']
                if flow['application']:
                    flow_type += '_'+flow['application']
                
                if flow['application'] == 'DNS' and 'detail_info' in flow:
                    for detail in flow['detail_info']:
                        if detail['dns_msg_type'] == 'QUERY':
                            behavior_input = ('behavior','host/'+flow_type,detail['query_name'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                        elif detail['dns_msg_type'] == 'ANSWER_IPV4':
                            behavior_input = ('behavior','dest_ip/'+flow_type,detail['ipv4_address'])
                            retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                elif 'protocol' in flow and (flow['protocol'] == 'TCP' or flow['protocol']=='UDP' or flow['protocol']=='IGMP' or flow['protocol']=='IGMP'):
                    if flow['dest_ip'] != '<MWS_GUEST_IP>':   # malwares.com virtual machine IP
                        behavior_input = ('behavior','dest_ip/'+flow_type,flow['dest_ip'])
                        retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                    elif flow['src_ip'] != '<MWS_GUEST_IP>':   # malwares.com virtual machine IP
                        behavior_input = ('behavior','src_ip/'+flow_type,flow['src_ip'])
                        retval = self.addExtractedInfo(behavior_input, add_result_to_system, retval, misp, misp_event)
                    
        if type(retval)==list and len(retval) > 0:  
            LibIoC_DK.debugging("The malware behavior info returned", main._DEBUG_, main._LOGGING_, main.hFile)
            return retval
        else:
            LibIoC_DK.debugging("The malware behavior info NOT returned", main._DEBUG_, main._LOGGING_, main.hFile)
            False
           
           
    ################################################################################################
    # Add extracted info from the repository into MISP system or into extracted info list.
    # The duplication of info in MISP is checked when it is added into the system or appended into the info list.
    # @ input
    #    info : the extracted information from the repository
    #    add_to_system : the indicator whether the info is added into MISP or appended into the info_list
    #    info_list : the information list extracted from the repository. If add_to_system is False, list type of parameter should be passed.
    #    misp : the MISP instance. This should not be False if add_to_system is True.
    #    misp_event : the MISP event this info is added. This should not be False if add_to_system is True.
    # @ output
    #    True or the info list is returned if the info is added into MISP or info_list.
    #    Otherwise, False is returned.
    def addExtractedInfo(self, info, add_to_system=False, info_list=None, misp=False, misp_event=False):
        if add_to_system and misp and misp_event:
            if misp and misp_event:
                return misp.addAttribute(misp_event, info)
        elif type(info_list) == list:
            if info_list.count(info) == 0:
                info_list.append(info)
            return info_list
            
    
    def getMalwareCollectedDate(self, _hash):
           
        _params = {
        'api_key': self.key,
        'hash': _hash,
        'env_type': 2
        }
        
        response = None
        try:
            LibIoC_DK.debugging("Getting the malware collection date: %s"%(_hash), main._DEBUG_, main._LOGGING_, main.hFile)
            response = requests.get('https://public.api.malwares.com/v3/file/mwsinfo', params=_params)
            self.query_counter = self.query_counter + 1
        except:
            print('getMalwareCollectedDate exception!')
            return False

        try:
            summary = response.json()
        except:
            LibIoC_DK.debugging("Exception occurred during decoding response", main._DEBUG_, main._LOGGING_, main.hFile)
            return False        
        
        if summary['result_code'] <= 0 and summary['result_code'] != 2:
            LibIoC_DK.debugging("Error returned while getting the malware collection date", main._DEBUG_, main._LOGGING_, main.hFile)
            return False
         
        return summary['first_seen'].encode('utf-8')[0:10]
    
    def waitToNextMidnight_UTC(self):
        LibIoC_DK.debugging("current time : %s UTC" % (str(datetime.utcnow())), main._DEBUG_, main._LOGGING_, main.hFile)
        LibIoC_DK.debugging("Wait to tomorrow 00:00 am. UTC", main._DEBUG_, main._LOGGING_, main.hFile)
        stop_d = datetime.utcnow().day
        while True:
            time.sleep(600)
            if datetime.utcnow().day > stop_d:
                break
        LibIoC_DK.debugging("Waked up!!!!", main._DEBUG_, main._LOGGING_, main.hFile)
        return
        
    def getAIScore(self, _hash):
        _params = {
        'api_key': self.key,
        'hash': _hash}
        response = None
        ai_score = None
        while True:
            try:
                LibIoC_DK.debugging("Getting the malware MAX score", main._DEBUG_, main._LOGGING_, main.hFile)
                response = requests.get('https://public.api.malwares.com/v3/file/mwsinfo', params=_params)
                self.query_counter = self.query_counter + 1
            except:
                LibIoC_DK.debugging("Exception occurred during the malware MAX score request", main._DEBUG_, main._LOGGING_, main.hFile)
                return False

            try:
                ai_score = response.json()
            except:
                LibIoC_DK.debugging("Exception occurred during decoding response", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
            if ai_score['result_code'] == 1: # Data exists
                break
            elif ai_score['result_code'] == 2:  # Analyzing
                LibIoC_DK.debugging("Analyzing the malware MAX score", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            elif ai_score['result_code'] == -14:  # Over the daily request limit
                LibIoC_DK.debugging("Over the daily request limit", main._DEBUG_, main._LOGGING_, main.hFile)
                LibIoC_DK.debugging("Accumulated the number of query: %d" %(self.query_counter), main._DEBUG_, main._LOGGING_, main.hFile)
                self.waitToNextMidnight_UTC()
                self.query_counter = 0
            elif ai_score['result_code'] <= 0:
                LibIoC_DK.debugging("Error returned while getting the malware MAX score", main._DEBUG_, main._LOGGING_, main.hFile)
                return False
            
        return ai_score['ai_score']
        
            
    def isNormalProcess(self, root, _hash):
        for p in root.findall('process'):
            if p.attrib['sha256'] == _hash:
                return True
        return False
    
    def openNormalProcessList(self):
        root = None
        if main.os.path.isfile(self.normal_process_list):
            tree = main.ET.parse(self.normal_process_list)
            root = tree.getroot()
        else:
            root = main.ET.Element('NormalFileList')
            tree = main.ET.ElementTree(root)
            tree.write(self.normal_process_list)
        return root
                        
    def addNormalProcessList(self, root, proc_path, _hash, ai_score):
        main.ET.SubElement(root, 'process', {'process_path':proc_path,'sha256':_hash, 'AI_score':ai_score})
        return
     
    def saveNormalProcessList(self, root):
        tree = main.ET.ElementTree(root)
        tree.write(self.normal_process_list)
        return


class Virustotal(MalwareRepositoryConnector):
    
    #############################
    # variables related to API key's property
    property={}
    property['request_rate'] = 4    # per minute
    property['daily_quota'] = 5760  # per day
    
    API_used_counter = {}
    API_used_counter['request_rate'] = 0    # per minute
    API_used_counter['daily_quota'] = 0  # per day
    
    minute_timer = None
    daily_timer = None
    
     
    def checkMinuteTimerLimit(self):
        return ((self.minute_timer-datetime.now()).total_seconds()) > 60
                   
    def checkRequestRate(self):
        return self.API_used['request_rate'] < self.property['request_rate']
    
    def checkDailyQuota(self):
        return self.API_used['daily_quota'] < self.property['daily_quota']
    